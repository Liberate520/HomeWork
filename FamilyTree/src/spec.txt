Структура:
    дерево должно иметь возможность описывать связи одного уровня
    скажем если есть я и сестра, то в иерархии мы будем на одном уровне
                        я - сестра
                    /       \
                    мама     папа

    таким образом, хоть сестра напрямую и не имеет "веток" до родителей,
    но должна иметь возможность получить их через связь со мной.

    в остальном каждый человек будет содержать связь со своими родителями.

    т.о. дерево предоставляет следующее API:
        1. добавление корня (происходит неявно - пользователь просто добавляет пользователя); - done.
        2. добавление тождественной ноды (для брата или сестры); - done.
            2.1. для тождественных нод должна быть возможность получения родителей
                через связанную ноду, а также получение всех братьев и сестёр (тождественных нод):
                2.1.1. в том числе если родители добавляются после добавления onelevelnode'ы,
                то они также должны появиться у onelevelnod'ы.
        3. получение данных - например, получение всех детей выбранного человека: - done.
        4. получение конкретной ноды и работа с ней; - done.
        5. вывод всего дерева - todo.


Сериализация:
    Не вижу смысла сериализовать ноду отдельно, так как дерево хранит все ноды, то они также будут серилизованы. Также при сериализации
    ноды - связанные с ней ноды также будут сериализованы, что, за небольшими отличиями, произойдёт и при серилизации дерева.

    1.  должен быть класс, который получает дерево на вход, и сериализует их.
        вызываться сериализация будет из клиентского кода.
        в конструкторе этот класс будет:
            * получать путь к файлу (или файл), в котором далее необходимо сохранить текущее состояние объекта (сериализовать);
        полученный файл передаётся в конструктор класса FileOutputStream.

        далее полученный объект FileOutputStream может быть передан в ObjectOutputStream 
        для дальнейшей серилизации получаемых объектов.

        -> т.о класс должен реализовать интерфейс записи в файл [FileWritable].

    2.  клиентский код должен сам кастовать полученные объекты к нужному типу,
        поскольку интерфейс должен быть гибким и не привязанным к конкретной реализации.
        особенно легко сделать это, учитывая то что для нашего случая серилизуется только дерево (см п.1).

    3.  следуя из того, что при сериализации дерева будут серилизованы все хранящиеся ноды,
        тогда и Node (как родительский класс), и Tree должны реализовать интерфейс Serializable

    оффтоп:
        !!! важно при этом учитывать, что этот класс предназначен не для сохранения данных
        в человеко-читаемом формате,
        а для сохранения состояния объектов и возможности восстановления этого состояния (десериализации).
        соответственно можно не беспокоиться о проблемах хранения и чтения из разных типов файлов (pdf, doc, etc...).